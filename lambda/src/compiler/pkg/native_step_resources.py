import logging
from typing import Generator, List

from . import state_machine_resources as sm
from .util import Step, Resource, State


def handle_native_step(step: Step,
                       wf_params: dict,
                       map_depth: int) -> Generator[Resource, None, List[State]]:
    logger = logging.getLogger(__name__)
    logger.info(f"making native step {step.name}")

    step_type = step.spec["Type"]

    ret = step.spec.copy()

    if step_type == "Parallel":
        sub_branches = []

        for branch in step.spec["Branches"]:
            sub_branch = yield from sm.make_branch(branch["steps"], wf_params, depth=map_depth)
            sub_branches.append(sub_branch)

        ret.update({"Branches": sub_branches})

    try:
        # if this native step was generated by the compiler, don't modify ResultPath or OutputPath
        ret.pop("_stet")

    except KeyError:
        if step_type not in {"Wait", "Succeed", "Fail"}:
            ret.update({"ResultPath": None})

        if step_type != "Fail":
            ret.update({"OutputPath": "$"})

    ret.pop("Next", None)
    ret.pop("End", None)

    if step_type not in {"Succeed", "Fail"}:
        ret.update(**step.next_or_end)

    return [State(step.name, ret)]
